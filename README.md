

## BUAA_CO_LAB_P5_P6: 流水线CPU设计与实现
前期的单周期项目的logisim建模
<img width="1488" height="993" alt="image" src="https://github.com/user-attachments/assets/9547d701-a3ad-499d-b937-10c31cf0812d" />


###  项目简介

本项目是北京航空航天大学计算机组成原理课程实验的**P5（基础流水线CPU）**和**P6（复杂指令集流水线CPU）**部分。项目基于**Verilog HDL**语言，从一个单周期CPU（P4）逐步迭代，最终实现了一个支持**转发（Forwarding）**、**阻塞（Stall）**和**复杂乘除指令**的五级流水线MIPS处理器。

这个仓库不仅包含了最终的实现代码，更是一份详尽的设计思路记录与“胎教级”教程，旨在帮助后续同学理解流水线CPU的核心概念，并提供一个清晰、模块化的实现参考。

###  项目亮点

*   **五级经典流水线结构**：实现了IF（取指）、ID（译码）、EXE（执行）、MEM（访存）、WB（写回）的经典五级流水线架构。
*   **分布式控制单元**：采用“分布式”设计，在每个流水级独立实例化控制单元，使得控制信号逻辑清晰，易于扩展。
*   **完善的数据冒险处理**：
    *   **全力转发 (Full Forwarding)**：通过在ID、EXE、MEM级设置转发逻辑，最大限度地解决了“读后写”（RAW）数据冒险，提升了CPU效率。
    *   **阻塞/暂停 (Stall)**：精确处理了Load-Use等转发无法解决的数据冒险，通过插入“气泡”来保证数据一致性。
*   **支持复杂指令 (P6)**：
    *   **乘除法单元**：实现了独立的乘除法模块，内置HI/LO寄存器，并通过**有限状态机**模拟了乘法（5周期）和除法（10周期）的运算延迟。
    *   **按字节访存**：支持 `lb`, `lh`, `sb`, `sh` 等非对齐内存访问指令。
*   **模块化与清晰命名**：代码结构清晰，遵循 `[流水级]_[模块名]_[信号名]` 的命名规范，可读性强，便于调试与维护。



**核心模块：**

| 模块             | 功能描述                                                     |
| ---------------- | ------------------------------------------------------------ |
| **PC**           | 程序计数器，负责指令寻址。                                   |
| **IM & DM**      | 指令存储器 (Instruction Memory) 和数据存储器 (Data Memory)。 |
| **GRF**          | 通用寄存器堆 (General Purpose Registers)。                   |
| **ALU**          | 算术逻辑单元，负责执行算术和逻辑运算。                       |
| **Control Unit** | 控制单元，根据指令操作码生成所有控制信号。                   |
| **CMP**          | 比较模块，用于处理分支指令的跳转条件。                       |
| **HILO**         | P6新增，负责处理乘除法运算、延迟及HI/LO寄存器。              |
| **流水线寄存器** | IF_ID, ID_EXE, EX_MEM, MEM_WB，负责在流水级间传递数据与控制信号。 |

### 🛠️ 设计哲学与关键实现

#### 1. 流水级独立性

本项目遵循“小车间独立性”的设计原则，将每个流水级视为一个相对独立的单元，它们之间仅通过流水线寄存器（传送带）进行通信。这一思想贯穿了整个设计，尤其体现在分布式控制单元和NextPC的实现上。

#### 2. 转发逻辑

转发的实现没有采用集中的转发单元模块，而是直接在需要数据的模块输入端（如ALU、CMP）进行判断和选择。这种方式更加直观，也简化了连线。转发优先级遵循“数据越新，优先级越高”的原则，即EXE级 -> MEM级 -> WB级，并实现了GRF内部的“写后读”转发。

#### 3. 阻塞机制

阻塞通过一个独立的`HazardDetectionUnit`模块实现。该模块基于`Tuse`（数据需要时间）和`Tnew`（数据产出时间）的核心思想，在检测到Load-Use冒险时，产生一个`Stall`信号。该信号会：
*   **冻结PC和IF_ID寄存器**：暂停流水线前半段的推进。
*   **清空ID_EXE寄存器**：向流水线后半段插入一个`nop`（气泡）。

###  如何使用

1.  **环境要求**：
    *   Verilog 仿真器（如ISE，Vivado, ModelSim, Veriwell等）。
    *   MIPS 汇编编译器（用于生成测试用的机器码）。

2.  **文件结构**：
    ```
    .
    ├── src/                # Verilog源代码
    │   ├── CPU.v           # CPU顶层模块
    │   ├── ALU.v           # 算术逻辑单元
    │   ├── ControlUnit.v   # 控制单元
    │   ├── ...             # 其他功能模块
    ├── testbench/          # 测试平台代码
    │   └── tb_cpu.v
    └── doc/                # 相关文档与设计说明
        └── design_notes.md # 设计思路与心得
    ```

3.  **运行仿真**：
    使用您的仿真工具编译`src`目录下的所有`.v`文件以及`testbench`中的测试文件，然后运行仿真即可观察波形和输出。

###  致谢

感谢课程组老师的指导，也感谢那些在我遇到困难时提供帮助的同学们。特别感谢阅读过我的[博客文章](<此处附上您的博客链接>)并给予积极反馈的读者，你们的鼓励是我完成这个项目并分享出来的重要动力！

希望这个项目能为后续学习计算机组成原理的同学提供一些参考和启发。如果发现任何问题或有改进建议，欢迎通过Issue或Pull Request进行交流！

